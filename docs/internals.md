# Internals of the Lanthanide package

Here you find the documentation of some classes and functions, which are not necessary for using the Lanthanide package,
but might be interesting, if you want to dig deeper. You can import each of them from `lanthanide`.

## HalfInt class

The value of quantum numbers of angular momenta in quantum mechanics in general may be integer or half-integer. The
class `HalfInt` is a lean solution for the representation of half-integer values. To create a `HalfInt` object, provide
its numerator as a parameter. The class supports basic mathematical operations involving other `HalfInt` or `int`
objects. Results with even numerator are converted into `int` objects:

```
from lanthanide import HalfInt
print(HalfInt(1) + 2 == HalfInt(5))
print(4 * HalfInt(3) == 6)
print(5 * HalfInt(1) == HalfInt(5))
print(HalfInt(5) >= 1)
print(HalfInt(1) - HalfInt(5) == -2)
print(HalfInt(3) - HalfInt(2) == HalfInt(1))
print(HalfInt(-3).numerator == -3)
```

The class has one attribute `numerator`:

```
print(HalfInt(-3).numerator == -3)
```

## Wigner symbols

The Lanthanide package uses Wigner 3-j symbols extensively to calculate matrix elements of tensor operators. To get the
value of a 3-j symbol

$$
\begin{pmatrix}
j_1 & j_2 & j_3 \\
m_1 & m_2 & m_3
\end{pmatrix}
$$

you use the function `wigner3j(j1, j2, j3, m1, m2, m3)`. The arguments may be either `int` or `HalfInt` objects:

```
from lanthanide import wigner3j
factor = wigner3j(2, HalfInt(3), HalfInt(3), 0, -HalfInt(1), HalfInt(1))
```

The Lanthanide package does not require Wigner 6-j symbols internally, because it builds tensor matrices in the space of
determinantal product states. However, if you want to process the matrices in higher-order coupling, you might be
interested in Wigner 6-j symbols

$$
\begin{Bmatrix}
j_1 & j_2 & j_3 \\
l_1 & l_2 & l_3
\end{Bmatrix}
$$

as well. For that purpose, the package provides the function `wigner6j(j1, j2, j3, l1, l2, l3)`. The arguments may be
either `int` or `HalfInt` objects again:

```
from lanthanide import wigner6j
factor = wigner6j(1, 2, 3, 2, 1, 2)
```

The calculation of Wigner symbols can be costly. Therefore, the Lanthanide package is using runtime caching for calls of
the functions `wigner3j` and `wigner6j`. Subsequent function calls with the same parameters take their result from the
cache.

## SingleElements class

The class `SingleElements` supports you with the calculation of matrices of your own one-, two- or three-electron
tensor operators in the determinantal product space. It exploits the fact that these matrices are necessarily
sparse because all matrix elements for which initial and final state differ in more electrons than the respective
tensor operator is acting on, must be zero.

The `SingleElements` object for the current configuration is available in the attribute `single` of a `Lanthanide`
object. Its method `elements(num)` generates the indices of the initial and the final state of each potentially
non-zero matrix element of a num-electron tensor operator together with a slice required for the evaluation of all
elementary tensor operators for this matrix element. The final and initial states of these elementary operators are
generated by the method `lower_keys(slice, num)` for the lower matrix triangle. In case of a non-symmetric tensor
operator, you also need to calculate the upper triangle elements. The final and initial states of the respective
elementary operators are generated by the method `upper_keys(slice, num)`. The binary bra-ket keys delivered by these
generators need to be be converted into tuples of final and initial electrons by the method `index_pair(key, num)`.

The following code provides an example of how to use `SingleElements` with your elementary tensor operator evaluation
function `operator()` of your own `num`-electron tensor operator. Note that the actual quantum numbers
$m_l$ and $m_s$ of the initial and final electrons are not required until just before the final evaluation of the
`operator()` function. They are extracted from the constant tuple `MAGNETIC` of all f electrons in standard order.
We calculate only elements in the lower triangle of the matrix here. This would be suitable for a symmetric operator.

```
from lanthanide import Lanthanide, MAGNETIC

def operator(initial, final):
    # ... place your code here ...
    return 0.42

with Lanthanide(2) as ion:
    num = 2
    for initial_index, final_index, key_slice in ion.single.elements(num):
        keys = ion.single.lower_keys(key_slice, num)
        value = 0.0
        for key, parity in keys:
            initial, final = ion.single.index_pair(key, num)
            quantum_initial = MAGNETIC[i] for i in initial
            quantum_final = MAGNETIC[i] for i in final
            sub_value = operator(quantum_initial, quantum_final)
            if parity == 0:
                value += sub_value
            else:
                value -= sub_value
        if value:
            print(f"Matrix element ({final_index}, {initial_index}) = {value}")
```

For a more optimized application you may investigate the module `unit`. An important feature of the implementation
in `unit` is caching of the value of evaluated elementary operators. For each set of initial and final elements the
elementary operator is thus evaluated only once.

## Unit tensor matrices

Unit tensor matrices in the determinantal product state space are provided as 2D numpy arrays via the function
`get_unit(ion, name)`.
If you want to force the calculation without using the file cache, you can also use `calc_unit(ion, name)`.
Here is a sample code segment to calculate the component $\mathrm{U}_{-1}^{(2)}$ of the unit tensor operator of
rank 2 in the orbital angular momentum space and the matrix of the two-electron scalar product
$(\mathbf{U}_1^{(2)}\cdot\mathbf{U}_2^{(2)})$:

```
from lanthanide import Lanthanide, get_matrix
with Lanthanide(2) as ion:
    k = 2
    q = -1
    matrix_1 = get_matrix(ion, f"U/a/{k},{q}")
    matrix_2 = get_matrix(ion, f"UU/b/{k}")
```

The following table lists all unit tensor operators provided by the Lanthanide package with their respective names:

| name                                 | electrons | tensor operator                                                                                                                 |
|--------------------------------------|-----------|---------------------------------------------------------------------------------------------------------------------------------|
| `U/a/{k},{q}`                        | 1         | $\mathrm{U}_{q}^{(k)}$                                                                                                          |
| `T/a/{k},{q}`                        | 1         | $\mathrm{T}_{q}^{(k)}$                                                                                                          |
| `UU/a/{k}`                           | 1         | $(\mathbf{U}^{(k)}\cdot\mathbf{U}^{(k)})$                                                                                       |
| `TT/a/{k}`                           | 1         | $(\mathbf{T}^{(k)}\cdot\mathbf{T}^{(k)})$                                                                                       |
| `UT/a/{k}`                           | 1         | $(\mathbf{U}^{(k)}\cdot\mathbf{T}^{(k)})$                                                                                       |
| `UU/b/{k}`                           | 2         | $(\mathbf{U}_1^{(k)}\cdot\mathbf{U}_2^{(k)})$                                                                                   |
| `TT/b/{k}`                           | 2         | $(\mathbf{T}_1^{(k)}\cdot\mathbf{T}_2^{(k)})$                                                                                   |
| `UT/b/{k}`                           | 2         | $(\mathbf{U}_1^{(k)}\cdot\mathbf{T}_2^{(k)})$                                                                                   |
| `UUTT/b/{ku1},{ku2},{kt1},{kt2},{k}` | 2         | $(\\{\mathbf{U}_1^{(ku1)}\times\mathbf{U}_2^{(ku2)}\\}^{(k)} \cdot \\{\mathbf{T}_1^{(kt1)}\times\mathbf{T}_2^{(kt2)}\\}^{(k)})$ |
| `UUU/c/{k1},{k2},{k3}`               | 3         | $(\mathbf{U}_1^{(k1)}\cdot\mathbf{U}_2^{(k2)}\cdot\mathbf{U}_2^{(k3)})$                                                         |

## Symmetry classes

Symmetry classes are used to store the representation of a certain state in a given symmetry group. The following
classes are available, including the two pseudo-symmetry classes `"tau"` and `"num"`, which are explained in the next
section:

| class         | name     | symbol | tensor operator   |
|---------------|----------|--------|-------------------|
| `SymmetryS2`  | `"S2"`   | $2S+1$ | $\mathbf{S}^2$    |
| `SymmetryGR7` | `"GR/7"` | $W$    | $\mathbf{G}(R_7)$ |
| `SymmetryGG2` | `"GG/2"` | $U$    | $\mathbf{G}(G_2)$ |
| `SymmetryL2`  | `"L2"`   | $L$    | $\mathbf{L}^2$    |
| `SymmetryJ2`  | `"J2"`   | $J$    | $\mathbf{J}^2$    |
| `SymmetryJz`  | `"Jz"`   | $M$    | $\mathrm{J}_z$    |
| `SymmetryTau` | `"tau"`  | $\tau$ |                   |
| `SymmetryNum` | `"num"`  |        |                   |

Name and symbol are available in the attributes `name` and `symbol` of the symmetry objects. The attribute `value`
contains the respective eigenvalue of the tensor operator which is converted into to integer `key` attribute when
the object is initialized. The `key` attribute is used when symmetry objects of the same symmetry group are ordered or
compared with the usual operators `<`, `<=`, `>`, `>=`, `==`, or `!=`. The classes support string conversion using
the Python function `str()`, which delivers the respective symmetry group representation string.

Lists of symmetry objects of the same symmetry group can be stored in a `SymmetryList` object. The most useful
method of this object for external applications is the method `count()` which returns a dictionary with the number
of symmetry objects for each different symmetry representation in the list. Two `SymmetryList` objects of the same
symmetry group can be concatenated using the `+` operator. The following sample code shows all representations of
the rotational group in 7 dimensions for Dy<sup>3+</sup> by diagonalising the matrix of the Casimir operator
$\mathbf{G}(R_7)$:

```
from lanthanide import Lanthanide, Coupling, SymmetryList
with Lanthanides(9) as ion:
    name = "GR/7"
    values, _ = ion.matrix(name).diagonalise()
    syms = SymmetryList(values, name)
    print(syms.count())
```

Note that the angular momentum symmetry objects all provide their quantum number as `int` or `HalfInt` value in
their respective special attributes `SymmetryS2.S`, `SymmetryL2.L`, `SymmetryJ2.J`, and `SymmetryJz.M`.

## State classes

The Lanthanide package provides four coupling schemes for electron states. These schemes are addressed using the
enumeration class `Coupling`. There is one class for each coupling scheme which acts as a list of state objects:

| coupling                     | coupling object    | state object   | state list object  |
|------------------------------|--------------------|----------------|--------------------|
| determinantal product states | `Coupling.Product` | `StateProduct` | `StateListProduct` |
| SLJM coupling                | `Coupling.SLJM`    | `StateSLJM`    | `StateListSLJM`    |
| SLJ coupling                 | `Coupling.SLJ`     | `StateSLJ`     | `StateListSLJ`     |
| intermediate SLJ coupling    | `Coupling.J`       | `StateJ`       | `StateListJ`       |

State objects provide numerical values in different attributes and two string formatting methods `short()`
and `long()` which return short and long string representations of the state, respectively. Calling `str(state)`
is equivalent to `state.long()`. The intended way to access state list objects is via the method
`Lanthanide.states()`:

```
from lanthanide import Lanthanide, Coupling
with Lanthanides(2) as ion:
    states = ion.states(Coupling.SLJ)
    for state in states:
        print(state)
```

The calculation of matrices of tensor operators in the Lanthanide package is carried out in the space of
determinantal product states. Each electron is described by a 5-tuple of quantum numbers: the shell number $n$, the
orbital angular momentum $l$, its z-component $m_l$, the spin $s$ and its z-component $m_s$. For lanthanide ions, three
of these quantum numbers are fixed: $n=4$, $l=3$, and $s=\frac12$. The remaining magnetic quantum numbers $m_l$ and
$m_s$ allow for a total of 14 combinations, $2l+1=7$ for $m_l$ and $2s+1=2$ for $m_s$. The standard order of these 14
different electrons is obtained by ordering $(m_l, m_s)$-tuples for decreasing values lexicographically.

The determinantal product states of a given lanthanide configuration with k electrons in the 4f shell are given by
all k-combinations of the 14 available electrons. We could thus use `itertools.combinations(range(14), k)` to get
the list of states. In order to keep the relationship to data in the file cache, we need to asure a defined and fixed order of
the states, although the order does not matter physically. The Lanthanide package therefore uses its own function
`product_states(k)` to determine the list of determinantal product states for a 4f configuration with k electrons.
Each state is represented by a tuple of indices into the list of different available electrons in standard order:

```
from lanthanide import product_states
product = product_states(3)
print(product)
```

The class `StateListProduct` takes this list of index tuples and provides a list of `StateProduct` objects representing
individual product states. The most relevant state attributes are the electron indices in `values` and the list of
$(l, m_l, s, m_s)$ tuples in `quantum`. The following sample code takes the determinantal product states of
Er<sup>3+</sup> and shows the state 2 in numerical and string format.

```
from lanthanide import Lanthanide, Coupling
with Lanthanide(3) as ion:
    states = ion.states(Coupling.Product)
    state = states[2]
    print("Indices:", state.values)
    print("Quantum numbers:", state.quantum)
    print("Short:", state.short())
    print("Long:", state.long())
```

The transformation of a tensor operator matrix $M$ from the product space into the SLJM space by the linear
transformation $M^\prime = V^T\cdot M\cdot V$ requires a transformation matrix $V$. The first step for the calculation
of this matrix is the diagonalisation of the tensor operator matrices `"S2"`, `"GR/7"`, `"GG/2"`, `"L2"`, `"J2"`, and
`"Jz"` in smaller and smaller subspaces. In this way the representation of each SLJM state in the respective symmetry
groups is determined. It turns out, that in the f configurations with 5-9 electrons, there are pairs of different
states left, which share the same set of symmetry representations (quantum numbers). In order to distinguish them, a
pseudo symmetry `"tau"` is introduced and ad-hoc numbers 1 and 2 are assigned to the states in these pairs, while
unique states get the value 0. Another pseudo symmetry `"num"` is introduced as an abbreviation code for states which
share the same quantum numbers S, L, and J. The final step in constructing the transformation to the SLJM space is a
phase adjustment of the transformation vectors, which are the columns of the matrix $V$. There is a degree of freedom
in the choice of the sign of these vectors, which is used to select the sign which allows the calculation of
reduced matrix elements inside the SLJ space without reference to the SLJM space.

The class `StateListSLJM` provides a list of `StateSLJM` objects representing individual states. Each state object
acts as a dictionary with symmetry names as keys and symmetry objects as values. Symmetry objects are described in
more detail below. The following sample code takes the SLJM states of Dy<sup>3+</sup> and prints details of state 3:

```
from lanthanide import Lanthanide, Coupling
with Lanthanide(9) as ion:
    states = ion.states(Coupling.SLJM)
    state = states[3]
    print("Short:", state.short())
    print("Long:", state.long(0.05))
    print(f"W = {state["GR/7"]}")
    print(f"U = {state["GG/2"]}")
```

The method `StateListSLJM.to_SLJ()` returns an object of the class `StateListSLJ` which provides a list of
`StateSLJ` objects representing individual states. It picks all stretched states with M=J and strips the symmetry
objects relating to `"Jz"`. The state object acts as a dictionary with symmetry names as keys and symmetry objects
as values. Symmetry objects are described in more detail below. The following sample code derives a `StateListSLJ`
object from an SLJM states object instead of using the method `Lanthanides.states()` directly:

```
from lanthanide import StateListProduct, Lanthanide
ion = Lanthanides(3)
states = StateListProduct(ion.product)
states = states.to_SLJM(ion)
states = states.to_SLJ()
for states in states:
    print(state)
```

## Matrix class

... to be added ...

