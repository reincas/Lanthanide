# Internals of the Lanthanide package

Here you find the documentation of some classes and functions, which are not necessary for using the Lanthanide package,
but might be interesting, if you want to dig deeper. You can import each of them from `lanthanide`.

## HalfInt class

The value of quantum numbers of angular momenta in quantum mechanics in general may be integer or half-integer. The
class `HalfInt` is a lean solution for the representation of half-integer values. To create a `HalfInt` object, provide
its numerator as a parameter. The class supports basic mathematical operations involving other `HalfInt` of `int`
objects. Results with even numerator are converted into `Ã¬nt` objects:

```
from lanthanide import HalfInt

print(HalfInt(1) + 2 == HalfInt(5))
print(4 * HalfInt(3) == 6)
print(5 * HalfInt(1) == HalfInt(5))
print(HalfInt(5) >= 1)
print(HalfInt(1) - HalfInt(5) == -2)
print(HalfInt(3) - HalfInt(2) == HalfInt(1))
print(HalfInt(-3).numerator == -3)
```

The class has one attribute `numerator`:

```
print(HalfInt(-3).numerator == -3)
```

## Wigner symbols

The Lanthanide package uses Wigner 3-j symbols extensively to calculate matrix elements of tensor operators. To get the
value of a 3-j symbol

$$
\begin{pmatrix}
j_1 & j_2 & j_3 \\
m_1 & m_2 & m_3
\end{pmatrix}
$$

you use the function `wigner3j(j1, j2, j3, m1, m2, m3)`. The arguments may be either `int` or `HalfInt` objects:

```
from lanthanide import wigner3j
factor = wigner3j(2, HalfInt(3), HalfInt(3), 0, -HalfInt(1), HalfInt(1))
```

The Lanthanide package does not require Wigner 6-j symbols internally, because it builds tensor matrices in the space of
determinantal product states. However, if you want to process the matrices in higher-order coupling, you might be
interested in Wigner 6-j symbols

$$
\begin{Bmatrix}
j_1 & j_2 & j_3 \\
l_1 & l_2 & l_3
\end{Bmatrix}
$$

as well. For that purpose, the package provides the function `wigner6j(j1, j2, j3, l1, l2, l3)`. The arguments may be
either `int` or `HalfInt` objects again:

```
from lanthanide import wigner6j
factor = wigner6j(1, 2, 3, 2, 1, 2)
```

The calculation of Wigner symbols can be costly. Therefore, the Lanthanide package is using runtime caching for calls of
the functions `wigner3j` and `wigner6j`. Subsequent function calls with the same parameters take their result from the
cache.

## SingleElements class

The class `SingleElements` supports you with the calculation of matrices of your own one-, two- or three-electron
tensor operators in the determinantal product space. It exploits the fact that these matrices are necessarily
sparse because all matrix elements between states which differ in more electrons than the respective tensor operator
is acting on, must be zero.

The `SingleElements` object for the current configuration is available in the attribute `single` of a `Lanthanide`
object. Its method `elements(num)` generates the indices of the initial and the final state of each potentially
non-zero matrix element of a num-electron tensor operator together with a slice required for the evaluation of all
elementary tensor operators for this matrix element. The final and initial states of these elementary operators are
generated by the method `lower_keys(slice, num)` for the lower matrix triangle. In case of a non-symmetric tensor
operator, you also need to calculate the upper triangle elements. The final and initial states of the respective
elementary operators are generated by the method `upper_keys(slice, num)`. The binary bra-ket keys delivered by these
generators need to be be converted into tuples of final and initial electrons by the method `index_pair(key, num)`.

The following code provides an example of how to use `SingleElements` with your elementary tensor operator evaluation
function `operator()` of your own `num`-electron tensor operator. Note that the actual quantum numbers
$m_l$ and $m_s$ of the initial and final electrons are only required for the final evaluation of the `operator()`
function. They are extracted from the constant tuple `MAGNETIC` of all f electrons in standard order. We calculate
only elements in the lower triangle of the matrix. This would be suitable for a symmetric operator.

```
from lanthanide import Lanthanide, MAGNETIC

def operator(initial, final):
    # ... place your code here ...
    return 0.42

with Lanthanide(2) as ion:
    num = 2
    for initial_index, final_index, key_slice in ion.single.elements(num):
        keys = ion.single.lower_keys(key_slice, num)
        value = 0.0
        for key, parity in keys:
            initial, final = ion.single.index_pair(key, num)
            quantum_initial = MAGNETIC[i] for i in initial
            quantum_final = MAGNETIC[i] for i in final
            sub_value = operator(quantum_initial, quantum_final)
            if parity == 0:
                value += sub_value
            else:
                value -= sub_value
        if value:
            print(f"Matrix element ({final_index}, {initial_index}) = {value}"=
```

For a more optimized application you may investigate the module `unit`. An important feature of the implementation
in `unit` is caching of the value of evaluated elementary operators.

## Matrix class

... to be added ...

## State classes

... to be added ...

