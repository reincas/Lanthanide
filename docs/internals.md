# Internals of the Lanthanide package

Here you find the documentation of some classes and functions, which are not necessary for using the Lanthanide package,
but might be interesting, if you want to dig deeper. You can import each of them from `lanthanide`.

## HalfInt class

The value of quantum numbers of angular momenta in quantum mechanics in general may be integer or half-integer. The
class `HalfInt` is a lean solution for the representation of half-integer values. To create a `HalfInt` object, provide
its numerator as a parameter. The class supports basic mathematical operations involving other `HalfInt` or `int`
objects. Results with even numerator are converted into `int` objects:

```
from lanthanide import HalfInt

print(HalfInt(1) + 2 == HalfInt(5))
print(4 * HalfInt(3) == 6)
print(5 * HalfInt(1) == HalfInt(5))
print(HalfInt(5) >= 1)
print(HalfInt(1) - HalfInt(5) == -2)
print(HalfInt(3) - HalfInt(2) == HalfInt(1))
print(HalfInt(-3).numerator == -3)
```

The class has one attribute `numerator`:

```
print(HalfInt(-3).numerator == -3)
```

## Wigner symbols

The Lanthanide package uses Wigner 3-j symbols extensively to calculate matrix elements of tensor operators. To get the
value of a 3-j symbol

$$
\begin{pmatrix}
j_1 & j_2 & j_3 \\
m_1 & m_2 & m_3
\end{pmatrix}
$$

you use the function `wigner3j(j1, j2, j3, m1, m2, m3)`. The arguments may be either `int` or `HalfInt` objects:

```
from lanthanide import wigner3j
factor = wigner3j(2, HalfInt(3), HalfInt(3), 0, -HalfInt(1), HalfInt(1))
```

The Lanthanide package does not require Wigner 6-j symbols internally, because it builds tensor matrices in the space of
determinantal product states. However, if you want to process the matrices in higher-order coupling, you might be
interested in Wigner 6-j symbols

$$
\begin{Bmatrix}
j_1 & j_2 & j_3 \\
l_1 & l_2 & l_3
\end{Bmatrix}
$$

as well. For that purpose, the package provides the function `wigner6j(j1, j2, j3, l1, l2, l3)`. The arguments may be
either `int` or `HalfInt` objects again:

```
from lanthanide import wigner6j
factor = wigner6j(1, 2, 3, 2, 1, 2)
```

The calculation of Wigner symbols can be costly. Therefore, the Lanthanide package is using runtime caching for calls of
the functions `wigner3j` and `wigner6j`. Subsequent function calls with the same parameters take their result from the
cache.

## SingleElements class

The class `SingleElements` supports you with the calculation of matrices of your own one-, two- or three-electron
tensor operators in the determinantal product space. It exploits the fact that these matrices are necessarily
sparse because all matrix elements between states which differ in more electrons than the respective tensor operator
is acting on, must be zero.

The `SingleElements` object for the current configuration is available in the attribute `single` of a `Lanthanide`
object. Its method `elements(num)` generates the indices of the initial and the final state of each potentially
non-zero matrix element of a num-electron tensor operator together with a slice required for the evaluation of all
elementary tensor operators for this matrix element. The final and initial states of these elementary operators are
generated by the method `lower_keys(slice, num)` for the lower matrix triangle. In case of a non-symmetric tensor
operator, you also need to calculate the upper triangle elements. The final and initial states of the respective
elementary operators are generated by the method `upper_keys(slice, num)`. The binary bra-ket keys delivered by these
generators need to be be converted into tuples of final and initial electrons by the method `index_pair(key, num)`.

The following code provides an example of how to use `SingleElements` with your elementary tensor operator evaluation
function `operator()` of your own `num`-electron tensor operator. Note that the actual quantum numbers
$m_l$ and $m_s$ of the initial and final electrons are not required before the final evaluation of the `operator()`
function. They are extracted from the constant tuple `MAGNETIC` of all f electrons in standard order. We calculate
only elements in the lower triangle of the matrix here. This would be suitable for a symmetric operator.

```
from lanthanide import Lanthanide, MAGNETIC

def operator(initial, final):
    # ... place your code here ...
    return 0.42

with Lanthanide(2) as ion:
    num = 2
    for initial_index, final_index, key_slice in ion.single.elements(num):
        keys = ion.single.lower_keys(key_slice, num)
        value = 0.0
        for key, parity in keys:
            initial, final = ion.single.index_pair(key, num)
            quantum_initial = MAGNETIC[i] for i in initial
            quantum_final = MAGNETIC[i] for i in final
            sub_value = operator(quantum_initial, quantum_final)
            if parity == 0:
                value += sub_value
            else:
                value -= sub_value
        if value:
            print(f"Matrix element ({final_index}, {initial_index}) = {value}"=
```

For a more optimized application you may investigate the module `unit`. An important feature of the implementation
in `unit` is caching of the value of evaluated elementary operators. For each set of initial and final elements the
elementary operator is thus evaluated only once.

## Unit tensor matrices

Unit tensor matrices in the determinantal product state space are provided as 2D numpy arrays via the function
`get_unit(ion, name)`.
If you want to force the calculation without using the file cache, you can also use `calc_unit(ion, name)`.
Here is a sample code segment to calculate the component $\mathrm{U}_{-1}^{(2)}$ of the unit tensor operator of
rank 2 in the orbital angular momentum space and the matrix of the two-electron scalar product
$(\mathbf{U}_1^{(2)}\cdot\mathbf{U}_2^{(2)})$:

```
from lanthanide import Lanthanide, get_matrix
with Lanthanide(2) as ion:
    k = 2
    q = -1
    matrix_1 = get_matrix(ion, f"U/a/{k},{q}")
    matrix_2 = get_matrix(ion, f"UU/b/{k}")
```

The following table lists all unit tensor operators provided by the Lanthanide package with their respective names:

| name                                 | electrons | tensor operator                                                                                                                 |
|--------------------------------------|-----------|---------------------------------------------------------------------------------------------------------------------------------|
| `U/a/{k},{q}`                        | 1         | $\mathrm{U}_{q}^{(k)}$                                                                                                          |
| `T/a/{k},{q}`                        | 1         | $\mathrm{T}_{q}^{(k)}$                                                                                                          |
| `UU/a/{k}`                           | 1         | $(\mathbf{U}^{(k)}\cdot\mathbf{U}^{(k)})$                                                                                       |
| `TT/a/{k}`                           | 1         | $(\mathbf{T}^{(k)}\cdot\mathbf{T}^{(k)})$                                                                                       |
| `UT/a/{k}`                           | 1         | $(\mathbf{U}^{(k)}\cdot\mathbf{T}^{(k)})$                                                                                       |
| `UU/b/{k}`                           | 2         | $(\mathbf{U}_1^{(k)}\cdot\mathbf{U}_2^{(k)})$                                                                                   |
| `TT/b/{k}`                           | 2         | $(\mathbf{T}_1^{(k)}\cdot\mathbf{T}_2^{(k)})$                                                                                   |
| `UT/b/{k}`                           | 2         | $(\mathbf{U}_1^{(k)}\cdot\mathbf{T}_2^{(k)})$                                                                                   |
| `UUTT/b/{ku1},{ku2},{kt1},{kt2},{k}` | 2         | $(\\{\mathbf{U}_1^{(ku1)}\times\mathbf{U}_2^{(ku2)}\\}^{(k)} \cdot \\{\mathbf{T}_1^{(kt1)}\times\mathbf{T}_2^{(kt2)}\\}^{(k)})$ |
| `UUU/c/{k1},{k2},{k3}`               | 3         | $(\mathbf{U}_1^{(k1)}\cdot\mathbf{U}_2^{(k2)}\cdot\mathbf{U}_2^{(k3)})$                                                         |

## State classes

The Lanthanide package provides four coupling schemes for electron states: `"Product"`, `"SLJM"`, `"SLJ"`, and the
intermediate SLJ coupling `"J"`. These schemes are addressed using the enumeration class `Coupling`. There is one class
for each coupling scheme which acts as a list of state objects:

| coupling object    | attribute `name` | state list object    | state object     |
|--------------------|------------------|----------------------|------------------|
| `Coupling.Product` | `"Product"`      | `"StateListProduct"` | `"StateProduct"` |
| `Coupling.SLJM`    | `"SLJM"`         | `"StateListSLJM"`    | `"StateSLJM"`    |
| `Coupling.SLJ`     | `"SLJ"`          | `"StateListSLJ"`     | `"StateSLJ"`     |
| `Coupling.J`       | `"J"`            | `"StateListJ"`       | `"StateJ"`       |

The intended way to access this data structure is via the method `states()` of the `Lanthanide` class:

```
from lanthanide import Lanthanide, Coupling

ion = Lanthanides(2)
states = ion.states(Coupling.SLJ.name)
for state in states:
    print(state)
```

State objects provide numerical values in different attributes and with two string formatting methods `short()`
and `long()` which return short and long string representations of the state, respectively. Calling `str(state)`
is equivalent to `state.long()`. 

In the following, the state objects are described in more detail, beginning with `"Product"`:
The calculation of matrices of tensor operators in the Lanthanide package is carried out in the space of
determinantal product states. Each electron is described by a 5-tuple of quantum numbers: the shell number $n$, the
orbital angular momentum $l$, its z-component $m_l$, the spin $s$ and its z-component $m_s$. For lanthanide ions, three
of these quantum numbers are fixed: $n=4$, $l=3$, and $s=\frac12$. The remaining magnetic quantum numbers $m_l$ and
$m_s$ allow for a total of 14 combinations, $2l+1=7$ for $m_l$ and $2s+1=2$ for $m_s$. The standard order of these 14
different electrons is obtained by ordering $(m_l, m_s)$-tuples for decreasing values lexicographically.

The determinantal product states of a given lanthanide configuration with k electrons in the 4f shell are given by
all k-combinations of the 14 available electrons. We could thus use `itertools.combinations(range(14), k)` to get
the list of states. Each state is represented by a tuple of indices into the list of available electrons in standard
order. In order to keep the relationship to data in the file cache, we need to asure a defined and fixed order of
the states, although the order does not matter physically. The Lanthanide package therefore uses its own function
`product_states(k)` to determine the list of determinantal product states for a 4f configuration with k electrons.

The class `StateListProduct` takes this list of index tuples and provides a list of `StateProduct` objects representing
individual product states. The most relevant state attributes are the electron indices in `values` and the list of
$(l, m_l, s, m_s)$ tuples in `quantum`. The following sample code generates the determinantal product states of
Er<sup>3+</sup> and shows the state 2 in numerical and string format.

```
from lanthanide import StateListProduct, product_states

product = product_states(3)
states = StateListProduct(product)
state = states[2]
print("Indices:", state.values)
print("Quantum numbers:", state.quantum)
print("Short:", state.short())
print("Long:", state.long())
```

The transformation of a tensor operator matrix $M$ from the product space into the SLJM space by the linear
transformation $M^\prime = V^T\cdot M\cdot V$ requires a transformation matrix $V$. The first step for the calculation
of this matrix is the diagonalisation of the tensor operator matrices `"S2"`, `"GR/7"`, `"GG/2"`, `"L2"`, `"J2"`, and
`"Jz"` in smaller and smaller subspaces. In this way the representation of each SLJM state in the respective symmetry
groups is determined. It turns out, that in the f configurations with 5-9 electrons, there are pairs of different
states left, which share the same set of symmetry representations (quantum numbers). In order to distinguish them, a
pseudo symmetry `"tau"` is introduced and ad-hoc numbers 1 and 2 are assigned to the states in these pairs, while
unique states get the value 0. Another pseudo symmetry `"num"` is introduced as an abbreviation code for states which
share the same quantum numbers S, L, and J. The final step in constructing the transformation to the SLJM space is a
phase adjustment of the transformation vectors, which are the columns of the matrix $V$. There is a degree of freedom
in the choice of the sign of these vectors, which is used to select the sign which allows the calculation of
reduced matrix elements inside the SLJ space without reference to the SLJM space.

The method `StateListProduct.to_SLJM(ion)` returns

```
from lanthanide import StateListProduct, StateListSLJM, Lanthanide

ion = Lanthanides(3)
states = StateListProduct(ion.product)
states = states.to_SLJM(ion)
assert isinstance(states, StateListSLJM)
state = states[2]
for states in states:
    print(state)
```

## Matrix class

... to be added ...

## Symmetry classes

... to be added ...
