# Internals of the Lanthanide package

Here you find the documentation of some classes and functions, which are not necessary for using the Lanthanide package,
but might be interesting, if you want to dig deeper. You can import each of them from `lanthanide`.

## HalfInt class

The value of quantum numbers of angular momenta in quantum mechanics in general may be integer or half-integer. The
class `HalfInt` is a lean solution for the representation of half-integer values. To create a `HalfInt` object, provide
its numerator as a parameter. The class supports basic mathematical operations involving other `HalfInt` or `int`
objects. Results with even numerator are converted into `int` objects:

```
from lanthanide import HalfInt
print(HalfInt(1) + 2 == HalfInt(5))
print(4 * HalfInt(3) == 6)
print(5 * HalfInt(1) == HalfInt(5))
print(HalfInt(5) >= 1)
print(HalfInt(1) - HalfInt(5) == -2)
print(HalfInt(3) - HalfInt(2) == HalfInt(1))
print(HalfInt(-3).numerator == -3)
```

The class has one attribute `numerator`:

```
print(HalfInt(-3).numerator == -3)
```

## Wigner symbols

The Lanthanide package uses Wigner 3-j symbols extensively to calculate matrix elements of tensor operators. To get the
value of a 3-j symbol

$$
\begin{pmatrix}
j_1 & j_2 & j_3 \\
m_1 & m_2 & m_3
\end{pmatrix}
$$

you use the function `wigner3j(j1, j2, j3, m1, m2, m3)`. The arguments may be either `int` or `HalfInt` objects:

```
from lanthanide import wigner3j
factor = wigner3j(2, HalfInt(3), HalfInt(3), 0, -HalfInt(1), HalfInt(1))
```

The Lanthanide package does not require Wigner 6-j symbols internally, because it builds tensor matrices in the space of
determinantal product states. However, if you want to process the matrices in higher-order coupling, you might be
interested in Wigner 6-j symbols

$$
\begin{Bmatrix}
j_1 & j_2 & j_3 \\
l_1 & l_2 & l_3
\end{Bmatrix}
$$

as well. For that purpose, the package provides the function `wigner6j(j1, j2, j3, l1, l2, l3)`. The arguments may be
either `int` or `HalfInt` objects again:

```
from lanthanide import wigner6j
factor = wigner6j(1, 2, 3, 2, 1, 2)
```

The calculation of Wigner symbols can be costly. Therefore, the Lanthanide package is using runtime caching for calls of
the functions `wigner3j` and `wigner6j`. Subsequent function calls with the same parameters take their result from the
cache.

## SingleElements class

The class `SingleElements` supports you with the calculation of matrices of your own one-, two- or three-electron
tensor operators in the determinantal product space. It exploits the fact that these matrices are necessarily
sparse because all matrix elements for which initial and final state differ in more electrons than the respective
tensor operator is acting on, must be zero.

The `SingleElements` object for the current configuration is available in the attribute `single` of a `Lanthanide`
object. Its method `elements(num)` generates the indices of the initial and the final state of each potentially
non-zero matrix element of a num-electron tensor operator together with a slice required for the evaluation of all
elementary tensor operators for this matrix element. The final and initial states of these elementary operators are
generated by the method `lower_keys(slice, num)` for the lower matrix triangle. In case of a non-symmetric tensor
operator, you also need to calculate the upper triangle elements. The final and initial states of the respective
elementary operators are generated by the method `upper_keys(slice, num)`. The binary bra-ket keys delivered by these
generators need to be be converted into tuples of final and initial electrons by the method `index_pair(key, num)`.

The following code provides an example of how to use `SingleElements` with your elementary tensor operator evaluation
function `operator()` of your own `num`-electron tensor operator. Note that the actual quantum numbers
$m_l$ and $m_s$ of the initial and final electrons are not required until just before the final evaluation of the
`operator()` function. They are extracted from the constant tuple `MAGNETIC` of all f electrons in standard order.
We calculate only elements in the lower triangle of the matrix here. This would be suitable for a symmetric operator.

```
from lanthanide import Lanthanide, MAGNETIC

def operator(initial, final):
    # ... place your code here ...
    return 0.42

with Lanthanide(2) as ion:
    num = 2
    for initial_index, final_index, key_slice in ion.single.elements(num):
        keys = ion.single.lower_keys(key_slice, num)
        value = 0.0
        for key, parity in keys:
            initial, final = ion.single.index_pair(key, num)
            quantum_initial = MAGNETIC[i] for i in initial
            quantum_final = MAGNETIC[i] for i in final
            sub_value = operator(quantum_initial, quantum_final)
            if parity == 0:
                value += sub_value
            else:
                value -= sub_value
        if value:
            print(f"Matrix element ({final_index}, {initial_index}) = {value}")
```

For a more optimized application you may investigate the module `unit`. An important feature of the implementation
in `unit` is caching of the value of evaluated elementary operators. For each set of initial and final elements the
elementary operator is thus evaluated only once.

## Unit tensor matrices

Unit tensor matrices in the determinantal product state space are provided as 2D numpy arrays via the function
`get_unit(ion, name)`.
If you want to force the calculation without using the file cache, you can also use `calc_unit(ion, name)`.
Here is a sample code segment to calculate the component $\mathrm{U}_{-1}^{(2)}$ of the unit tensor operator of
rank 2 in the orbital angular momentum space and the matrix of the two-electron scalar product
$(\mathbf{U}_1^{(2)}\cdot\mathbf{U}_2^{(2)})$:

```
from lanthanide import Lanthanide, get_unit
with Lanthanide(2) as ion:
    k = 2
    q = -1
    matrix_1 = get_unit(ion, f"U/a/{k},{q}")
    matrix_2 = get_unit(ion, f"UU/b/{k}")
```

The following table lists all unit tensor operators provided by the Lanthanide package with their respective names,
where $\mathrm{u}_{q}^{(k)}$ is the unit tensor operator of rank $k$ in the space of orbital angular momentum and
$\mathrm{t}_{q}^{(k)}$ in the spin space:  

| name                                   | tensor operator                                                                                                                                                 | rank | parameters                         |
|----------------------------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------|------|------------------------------------|
| `"U/a/{k},{q}"`                        | $\sum\limits_i\mathrm{u}_{i,q}^{(k)}$                                                                                                                           | $k$  | $k = 0\ldots2l$, $q = -k\ldots +k$ |
| `"T/a/{k},{q}"`                        | $\sum\limits_i\mathrm{t}_{i,q}^{(k)}$                                                                                                                           | $k$  | $k = 0, 1$, $q = -k\ldots +k$      |
| `"UU/a/{k}"`                           | $\sum\limits_i\left(\mathbf{u}_i^{(k)}\cdot\mathbf{u}_i^{(k)}\right)$                                                                                           | 0    | $k = 0\ldots2l$                    |
| `"TT/a/{k}"`                           | $\sum\limits_i\left(\mathbf{t}_i^{(k)}\cdot\mathbf{t}_i^{(k)}\right)$                                                                                           | 0    | $k = 0, 1$                         |
| `"UT/a/{k}"`                           | $\sum\limits_i\left(\mathbf{u}_i^{(k)}\cdot\mathbf{t}_i^{(k)}\right)$                                                                                           | 0    | $k = 0, 1$                         |
| `"UU/b/{k}"`                           | $\sum\limits_{i<j}\left(\mathbf{u}_i^{(k)}\cdot\mathbf{u}_j^{(k)}\right)$                                                                                       | 0    | $k = 0\ldots2l$                    |
| `"TT/b/{k}"`                           | $\sum\limits_{i<j}\left(\mathbf{t}_i^{(k)}\cdot\mathbf{t}_j^{(k)}\right)$                                                                                       | 0    | $k = 0, 1$                         |
| `"UT/b/{k}"`                           | $\sum\limits_{i<j}\left(\mathbf{u}_i^{(k)}\cdot\mathbf{t}_j^{(k)}\right)$                                                                                       | 0    | $k = 0, 1$                         |
| `"UUTT/b/{ku1},{ku2},{kt1},{kt2},{k}"` | $\sum\limits_{i<j}\left(\\{\mathbf{u}_i^{(ku_1)}\times\mathbf{u}_j^{(ku_2)}\\}^{(k)} \cdot \\{\mathbf{t}_i^{(kt_1)}\times\mathbf{t}_j^{(kt_2)}\\}^{(k)}\right)$ | 0    | $ku_i = 0\ldots2l$, $kt_i = 0, 1$  |
| `"UUU/c/{k1},{k2},{k3}"`               | $\sum\limits_{i<j<k}\left(\mathbf{u}_i^{(k_1)}\cdot\mathbf{u}_j^{(k_2)}\cdot\mathbf{u}_k^{(k_3)}\right)$                                                        | 0    | $k_i = 0\ldots2l$                  |

Note that the intended way to receive any tensor operator matrix including unit tensor operators is the method
`Lanthanide.matrix(name, coupling)`. This method is explained below and delivers a `Matrix` object in the given
coupling space.

## Symmetry classes

Symmetry classes are used to store the representation of a certain state in a given symmetry group. The following
classes are available, including the two pseudo-symmetry classes `"tau"` and `"num"`, which are explained in the next
section:

| class         | name     | symbol | tensor operator   |
|---------------|----------|--------|-------------------|
| `SymmetryS2`  | `"S2"`   | $2S+1$ | $\mathbf{S}^2$    |
| `SymmetryGR7` | `"GR/7"` | $W$    | $\mathbf{G}(R_7)$ |
| `SymmetryGG2` | `"GG/2"` | $U$    | $\mathbf{G}(G_2)$ |
| `SymmetryL2`  | `"L2"`   | $L$    | $\mathbf{L}^2$    |
| `SymmetryJ2`  | `"J2"`   | $J$    | $\mathbf{J}^2$    |
| `SymmetryJz`  | `"Jz"`   | $M$    | $\mathrm{J}_z$    |
| `SymmetryTau` | `"tau"`  | $\tau$ |                   |
| `SymmetryNum` | `"num"`  |        |                   |

Name and symbol are available in the attributes `name` and `symbol` of the symmetry objects. The attribute `value`
contains the respective eigenvalue of the tensor operator which is converted into to integer `key` attribute when
the object is initialized. The `key` attribute is used when symmetry objects of the same symmetry group are ordered or
compared with the usual operators `<`, `<=`, `>`, `>=`, `==`, or `!=`. The classes support string conversion using
the Python function `str()`, which delivers the respective symmetry group representation string.

Lists of symmetry objects of the same symmetry group can be stored in a `SymmetryList` object. The most useful
method of this object for external applications is the method `count()` which returns a dictionary with the number
of symmetry objects for each different symmetry representation in the list. Two `SymmetryList` objects of the same
symmetry group can be concatenated using the `+` operator. The following sample code shows all representations of
the rotational group in 7 dimensions for Dy<sup>3+</sup> by diagonalising the matrix of the Casimir operator
$\mathbf{G}(R_7)$:

```
from lanthanide import Lanthanide, Coupling, SymmetryList
with Lanthanides(9) as ion:
    name = "GR/7"
    values, _ = ion.matrix(name).diagonalise()
    syms = SymmetryList(values, name)
    print(syms.count())
```

Note that the angular momentum symmetry objects all provide their quantum number as `int` or `HalfInt` value in
their respective special attributes `SymmetryS2.S`, `SymmetryL2.L`, `SymmetryJ2.J`, and `SymmetryJz.M`.

## State classes

The Lanthanide package provides four coupling schemes for electron states. These schemes are addressed using the
enumeration class `Coupling`. There is one class for each coupling scheme which acts as a list of state objects:

| coupling                     | coupling object    | state object   | state list object  |
|------------------------------|--------------------|----------------|--------------------|
| determinantal product states | `Coupling.Product` | `StateProduct` | `StateListProduct` |
| SLJM coupling                | `Coupling.SLJM`    | `StateSLJM`    | `StateListSLJM`    |
| SLJ coupling                 | `Coupling.SLJ`     | `StateSLJ`     | `StateListSLJ`     |
| intermediate SLJ coupling    | `Coupling.J`       | `StateJ`       | `StateListJ`       |
| intermediate SLJM coupling   | `Coupling.JM`      | `StateJM`      | `StateListJM`      |

State objects provide numerical values in different attributes and two string formatting methods `short()`
and `long()` which return short and long string representations of the state, respectively. Calling `str(state)`
is equivalent to `state.long()`. The intended way to access state list objects is via the method
`Lanthanide.states()`:

```
from lanthanide import Lanthanide, Coupling
with Lanthanides(2) as ion:
    states = ion.states(Coupling.SLJ)
    for state in states:
        print(state)
```

The calculation of matrices of tensor operators in the Lanthanide package is carried out in the space of
determinantal product states. Each electron is described by a 5-tuple of quantum numbers: the shell number $n$, the
orbital angular momentum $l$, its z-component $m_l$, the spin $s$ and its z-component $m_s$. For lanthanide ions, three
of these quantum numbers are fixed: $n=4$, $l=3$, and $s=\frac12$. The remaining magnetic quantum numbers $m_l$ and
$m_s$ allow for a total of 14 combinations, $2l+1=7$ for $m_l$ and $2s+1=2$ for $m_s$. The standard order of these 14
different electrons is obtained by ordering $(m_l, m_s)$-tuples for decreasing values lexicographically.

The determinantal product states of a given lanthanide configuration with k electrons in the 4f shell are given by
all k-combinations of the 14 available electrons. We could thus use `itertools.combinations(range(14), k)` to get
the list of states. In order to keep the relationship to data in the file cache, we need to asure a defined and fixed
order of
the states, although the order does not matter physically. The Lanthanide package therefore uses its own function
`product_states(k)` to determine the list of determinantal product states for a 4f configuration with k electrons.
Each state is represented by a tuple of indices into the list of different available electrons in standard order:

```
from lanthanide import product_states
product = product_states(3)
print(product)
```

The class `StateListProduct` takes this list of index tuples and provides a list of `StateProduct` objects representing
individual product states. The most relevant state attributes are the electron indices in `values` and the list of
$(l, m_l, s, m_s)$ tuples in `quantum`. The following sample code takes the determinantal product states of
Nd<sup>3+</sup> and shows the state 2 in numerical and string format.

```
from lanthanide import Lanthanide, Coupling
with Lanthanide(3) as ion:
    states = ion.states(Coupling.Product)
    state = states[2]
    print("Indices:", state.values)
    print("Quantum numbers:", state.quantum)
    print("Short:", state.short())
    print("Long:", state.long())
```

The transformation of a tensor operator matrix $M$ from the product space into the SLJM space by the linear
transformation $M^\prime = V^T\cdot M\cdot V$ requires a transformation matrix $V$. The first step for the calculation
of this matrix is the diagonalisation of the tensor operator matrices `"S2"`, `"GR/7"`, `"GG/2"`, `"L2"`, `"J2"`, and
`"Jz"` in smaller and smaller subspaces. In this way the representation of each SLJM state in the respective symmetry
groups is determined. It turns out, that in the f configurations with 5-9 electrons, there are pairs of different
states left, which share the same set of symmetry representations (quantum numbers). In order to distinguish them, a
pseudo symmetry `"tau"` is introduced and ad-hoc numbers 1 and 2 are assigned to the states in these pairs, while
unique states get the value 0. Another pseudo symmetry `"num"` is introduced as an abbreviation code for states which
share the same quantum numbers S, L, and J. The final step in constructing the transformation to the SLJM space is a
phase adjustment of the transformation vectors, which are the columns of the matrix $V$. There is a degree of freedom
in the choice of the sign of these vectors, which is used to select the sign which allows the calculation of
reduced matrix elements inside the SLJ space without reference to the SLJM space.

The class `StateListSLJM` provides a list of `StateSLJM` objects representing individual states. Each state object
acts as a dictionary with symmetry names as keys and symmetry objects as values. The following sample code takes
the SLJM states of Dy<sup>3+</sup> and prints details of state 3:

```
from lanthanide import Lanthanide, Coupling
with Lanthanide(9) as ion:
    states = ion.states(Coupling.SLJM)
    state = states[3]
    print("Short:", state.short())
    print("Long:", state.long())
    print(f"W = {state["GR/7"]}")
    print(f"U = {state["GG/2"]}")
```

The SLJ sub-space consists of all stretched SLJM states with M=J. The class `StateListSLJ` provides a list of
`StateSLJ` objects representing individual states. The state object `StateSLJ` again acts as a dictionary with
symmetry names as keys and symmetry objects as values. It is identical to a `StateSLJM` object without the `"Jz"`
symmetry. The following sample code takes the SLJ states of Pr<sup>3+</sup> and prints long string representations
of all states:

```
from lanthanide import Lanthanide, Coupling
with Lanthanide(2) as ion:
    states = ion.states(Coupling.SLJ)
    for states in states:
        print(state)
```

The perturbation hamiltonians preserve only symmetry in $R_3$, thus only the quantum number J of the total angular
momentum. The physical states of lanthanide ions are therefore intermediate states. Each state is a linear combination
of different SLJ states with the same quantum number J. The class `StateListJ` provides a list of `StateJ` objects
representing individual states in intermediate SLJ coupling in the order of their energy levels, which are
available in the attribute `energies`.

The state object `StateJ` keeps a linear combination of all SLJ states with the same J. The attribute `values`
contains the respective factors, `weights` the squared factors, `states` the respective list of `StateSLJ`
objects, and `energy` the energy of the state. The short string representation of a state in intermediate coupling
is that of its SLJ component with largest weight. Note that this can result in more than one state with exactly the
same label. The long representation of a state lists the SLJ components with their weight in descending order. In
order to limit the length of the representation strings, the method `StateJ.long()` may be called with an optional
argument `min_weight` to include only SLJ components with at least the given weight in the representation string.
The following sample code takes the intermediate states of Er<sup>3+</sup> and prints long string representations
of all states:

```
from lanthanide import Lanthanide, Coupling
with Lanthanide(11) as ion:
    states = ion.intermediate
    for states in states:
        print(state.long(min_weight=0.05))
```

The state object `StateJM` keeps a linear combination of all SLJM states, although usually a small number of SLJM
states dominates. The attribute `values` contains the respective factors, `weights` the squared factors, `states` the
full list of `StateSLJM` objects, and `energy` the energy of the state. The short string representation of a state in
intermediate coupling is that of its SLJM component with largest weight. Note that this can result in more than one
state with exactly the same label. The long representation of a state lists the SLJM components with their weight in
descending order. In order to limit the length of the representation strings, the method `StateJM.long()` may be
called with an optional argument `min_weight` to include only SLJM components with at least the given weight in the
representation string. The following sample code takes the intermediate SLJM states of Pr<sup>3+</sup> and prints
long string representations of all states:

```
from lanthanide import Lanthanide, Coupling
with Lanthanide(11, coupling.SLJM) as ion:
    states = ion.intermediate
    for states in states:
        print(state.long(min_weight=0.05))
```

## Matrix class

The Lanthanide package encapsulates matrices of tensor operators in `Matrix` objects. The matrices of predefined
tensor operators in any coupling scheme are provided by the method `Lanthanide.matrix()`. Specification of the
coupling class is optional. Default is the coupling scheme of the `Lanthanide` object. The following sample code
gets the matrix of the intra-configuration Coulomb interaction of rank 2 in SLJ coupling for the Yb<sup>3+</sup>
ion:

```
from lanthanide import Lanthanide, Coupling
with Lanthanide(13) as ion:
    matrix = ion.matrix("H1/2", Coupling.SLJ)
```

In addition to the unit tensor operators tabulated above, the following table contains all predefined tensor
operators the matrices of which can be obtained by the method `Lanthanide.matrix()`:

| name            | operator                                               | rank | parameters                         |
|-----------------|--------------------------------------------------------|------|------------------------------------|
| `"UU/{k}"`      | $(\mathbf{U}^{(k)}\cdot\mathbf{U}^{(k)})$              | 0    | $k = 0\ldots 2l$                   |  
| `"TT/{k}"`      | $(\mathbf{T}^{(k)}\cdot\mathbf{T}^{(k)})$              | 0    | $k = 0, 1$                         |  
| `"UT/{k}"`      | $(\mathbf{U}^{(k)}\cdot\mathbf{T}^{(k)})$              | 0    | $k = 0, 1$                         |  
| `"L/{q}"`       | $\mathbf{L}_{q}$                                       | 1    | $q = -1, 0, +1$                    |  
| `"S/{q}"`       | $\mathbf{S}_{q}$                                       | 1    | $q = -1, 0, +1$                    |  
| `"J/{q}"`       | $\mathbf{J}_{q}$                                       | 1    | $q = -1, 0, +1$                    |  
| `"Lz"`          | $\mathbf{L}_{0}$                                       |      |                                    |  
| `"Sz"`          | $\mathbf{S}_{0}$                                       |      |                                    |  
| `"Jz"`          | $\mathbf{J}_{0}$                                       |      |                                    |  
| `"L2"`          | $(\mathbf{L}\cdot\mathbf{L})$                          | 0    |                                    |  
| `"LS"`          | $(\mathbf{L}\cdot\mathbf{S})$                          | 0    |                                    |  
| `"S2"`          | $(\mathbf{S}\cdot\mathbf{S})$                          | 0    |                                    |  
| `"J2"`          | $(\mathbf{J}\cdot\mathbf{J})$                          | 0    |                                    |  
| `"ED/{k},{q}"`  | $\mathbf{U}^{(k)}_{q}$                                 | $k$  | $k = 0\ldots 2l$, $q = -k\ldots +k$ |  
| `"MD/{q}"`      | $\mathbf{L}\_{q} + g\_s\mathbf{S}\_{q}$                | 1    | $q = -1, 0, +1$                    |  
| `"GR/{d}"`      | $\mathbf{G}(R_{d})$                                    | 0    | $d = 3, 5, 7$                      |  
| `"GG/{d}"`      | $\mathbf{G}(G_{d})$                                    | 0    | $d = 2$                            |  
| `"H1/{k}"`      | $\mathbf{f}_k$                                         | 0    | $k = 0\ldots 2l$                   |
| `"H2"`          | $\mathbf{z}$                                           | 0    |                                    |
| `"H3/0"`        | $(\mathbf{L}\cdot\mathbf{L})$                          | 0    |                                    |
| `"H3/1"`        | $\mathbf{G}(R_7)$                                      | 0    |                                    |
| `"H3/2"`        | $\mathbf{G}(G_2)$                                      | 0    |                                    |
| `"H4/{c}"`      | $\mathbf{t}_c$                                         | 0    | $c = 1\ldots 9$                    |
| `"hss/{k}"`     | $\mathbf{m}_{k,ss}$                                    | 0    | $k = 0, 2, 4$                      |
| `"hsoo/{k}"`    | $\mathbf{m}_{k,soo}$                                   | 0    | $k = 0, 2, 4$                      |
| `"H5/{k}"`      | $\mathbf{m}_k$                                         | 0    | $k = 0, 2, 4$                      |
| `"H5fix"`       | $\mathbf{m}_0 + 0.56 \mathbf{m}_2 + 0.38 \mathbf{m}_4$ | 0    |                                    |
| `"H6/{k}"`      | $\mathbf{p}_k$                                         | 0    | $k = 2, 4, 6$                      |
| `"H6fix"`       | $\mathbf{p}_2 + 0.75 \mathbf{p}_4 + 0.50 \mathbf{p}_6$ | 0    |                                    |
| `"Hcf/{k},{q}"` | $\mathbf{C}^{(k)}_{q}$                                 | $k$  | $k = 0\ldots 2l$, $q = 0\ldots k$  |  

The `Matrix` objects support basic arithmetic operations to build real and complex linear combinations of them:

```
from lanthanide import Lanthanide
with Lanthanide(3) as ion:
    matrix = ion.matrix("H1/2")
    matrix += ion.matrix("UU/b/4")
    matrix += ion.matrix("H5/0") + 0.123 * ion.matrix("H5/2") - 0.234 * ion.matrix("H5/4")
    matrix /= 2.7  
```

A `Matrix` object can be transformed to a different coupling scheme, using its method `transform(coupling)`. Calling
the method `diagonalise()` on a symmetric matrix delivers the vector of eigenvalues and the array of eigenvectors
(columns). If the coupling scheme of the matrix is SLJM or SLJ, the method `fast_diagonalise()` provides a faster
means of diagonalising the matrix utilizing the sorted J spaces of these coupling schemes.

The generation of your own `Matrix` object from a given 2D numpy array requires a `Lanthanide` object in the first
argument `ion` and the array in the second argument `array`. This is followed by an optional `name` string and the
optional `coupling` class (default: `Coupling.Product`) of the given numeric array:

```
from lanthanide import Lanthanide, Coupling, Matrix
with Lanthanide(1) as ion:
    coupling = Coupling.SLJ
    num = ion.num_states(coupling)
    array = np.random((num, num), dtype=float)
    matrix = Matrix(ion, array, "foo", coupling)
```

The function `build_hamilton()` assembles and returns a perturbation hamiltonian in SLJM or SLJ coupling as `Matrix`
object. It takes all tensor operator matrices given by the keys of the dictionary `radials` which start with the
capital letter "H" in the given `coupling` and builds a linear combination using the values of the dictionary as
factors.

```
from lanthanide import Lanthanide, Coupling, build_hamilton
with Lanthanide(4) as ion:
    radial = { "H1/2": 68576.05, "H1/4": 49972.76, "H1/6": 32415.29, "H2": 728.18 }
    H = build_hamilton(ion, radial, Coupling.SLJM)
```

Reduced matrix elements are available from the method `Lanthanide.reduced()` by giving the `name` of the tensor
operator and the optional `coupling` scheme, which might be SLJ or intermediate SLJ (default). Note that the name
must contain a "{q}" to address the different tensor components if the rank of the tensor is not zero. The result
is returned as 2D numpy array:

```
from lanthanide import Lanthanide, Coupling
with Lanthanide(9) as ion:
    reduced = ion.reduced("H5/2", Coupling.SLJ)
```

## Alternative parameter sets

The Lanthanide package supports some definitions of radial parameters which are often found in older literature. They 
are automatically converted into the standard set when you use them in your dictionary of radial integrals. The
attribute `ion.radial` always contains the standard set of converted values.

The radial integrals $F_0$, $F_2$, $F_4$, and $F_6$ with sub-script instead of super-script were used in the past to
avoid fractional coefficients in the numeric calculations. You can specify them using the keys `F_0`, `F_2`, `F_4`,
and `F_6`. The same holds for $P_2$, $P_4$, and $P_6$ which you can use with the keys `P_2`, `P_4`, and `P_6`.

The 1st order Coulomb interaction parameters $E^0$, $E^1$, $E^2$, and $E^3$ are somewhat different, because each of
them is a linear combination of the standard set $F^0$, $F^2$, $F^4$, and $F^6$. You can use them with the keys `E^0`,
`E^1`, `E^2`, and `E^3`.