##########################################################################
# Copyright (c) 2025 Reinhard Caspary                                    #
# <reinhard.caspary@phoenixd.uni-hannover.de>                            #
# This program is free software under the terms of the MIT license.      #
##########################################################################
#
# Compare matrices from the old Lanthanide-0.3 code with new ones.
#
##########################################################################

import pickle
import numpy as np

from lanthanide import Lanthanide, Coupling

OLDFILE = "../../Lanthanide-0.3/test/extract/f{num:02d}.data"

def get_phase(array_old, array_new):
    assert isinstance(array_old, np.ndarray)
    assert isinstance(array_new, np.ndarray)
    assert array_old.shape == array_new.shape

    sign = np.zeros_like(array_old, dtype=int)
    for i in range(0, array_new.shape[0]):
        for j in range(0, array_new.shape[1]):
            value_old = array_old[i, j]
            value_new = array_new[i, j]
            if abs(value_new) < 1e-7 and abs(value_old) < 1e-7:
                continue
            assert abs(value_new * value_old) > 1e-7
            assert abs(abs(value_new) - abs(value_old)) < 1e-7
            sign[i, j] = -1 if value_new * value_old < 0 else 1

    new_signs = np.zeros(array_new.shape[1], dtype=int)
    for j in range(new_signs.shape[0]):
        sign_j = set([s for s in sign[:, j] if s != 0])
        assert len(sign_j) == 1
        new_signs[j] = sign_j.pop()
    return new_signs

# Correct for wrong list of l letters in lanthanide-0.3
CORRECT = {
    "1P12": "1Q12",
    "2P23/2": "2Q23/2",
    "2P25/2": "2Q25/2",
}

def new_name(old_name):
    if "[" in old_name:
        slj, j = old_name.split("[", 1)
        j = j.replace("]", "")
    else:
        slj, j = old_name, None
    if "(" in slj:
        a = slj.index("(")
        b = slj.index(")")
        slj = slj[:a] + slj[b + 1:] + slj[a:b + 1]
    if j is None:
        name = slj
    else:
        name = slj + " " + j
    if name in CORRECT:
        name = CORRECT[name]
    return name


def compare_old(num, show=False):
    """ Compare matrices generated by the old Lanthanide-0.3 package with current ones. """

    # Retrieve data dictionary from Lanthanide-0.3
    with open(OLDFILE.format(num=num), "rb") as fp:
        data = fp.read()
    data = pickle.loads(data)

    # Extract coupling
    coupling = {
        "product": Coupling.Product,
        "sljm": Coupling.SLJM,
        "slj": Coupling.SLJ,
    }[data["coupling"]]

    # Initialize Lanthanide object
    with Lanthanide(num) as ion:
        if show:
            print(ion)

        # Get old and new (short) state names
        states_new = ion.states(coupling)
        names_old = data["names"] if "names" in data else None
        names_new = states_new.short()
        if coupling != Coupling.Product:
            #names_old = [name.replace("[", " ").replace("]", "") for name in names_old]
            names_old = [new_name(name) for name in names_old]
        if set(names_new) != set(names_old):
            print("only new:", set(names_new) - set(names_old))
            print("only old:", set(names_old) - set(names_new))
        assert set(names_new) == set(names_old)

        # Create index map to re-index old matrices to new state order
        new_indices = [names_old.index(name) for name in names_new] if names_old else None

        # Get sign map to adjust the phase of the old transfomation vectors to the new phases
        transform_old = np.array(data["vectors"]).T if "vectors" in data else None
        new_signs = None
        if transform_old is not None:
            transform_old = transform_old[:, new_indices]
            transform_new = ion.states(coupling).transform
            assert transform_new.shape == transform_old.shape
            if num < 5 or num > 9:
                new_signs = get_phase(transform_old, transform_new)

        # Extract and process all matrices
        for key_old in sorted(data.keys()):
            if key_old in ("coupling", "names", "mode", "vectors"):
                continue

            # Load and re-index old matrix
            array_old = np.array(data[key_old])
            if coupling != Coupling.Product:
                array_old = array_old[new_indices, :]
                array_old = array_old[:, new_indices]

            # Adjust state phases
            if new_signs is not None:
                array_old *= np.outer(new_signs, new_signs)

            # Translate old matrix name to new one
            args = key_old.split(":")
            name_new = {
                "U1U2T1T2": "UUTT/b/{0},{1},{2},{3},{4}",
                "U1U2": "UU/b/{0}",
                "Hss": "hss/{0}",
                "Hsoo": "hsoo/{0}",
                "H1": "H1/{0}",
                "H2": "H2",
                "H3": "H3/{0}",
                "H4": "H4/{0}",
                "H5": "H5/{0}",
                "H6": "H6/{0}",
            }[args[0]]
            name_new = name_new.format(*map(int, args[1:]))

            # Get new matrix
            array_new = ion.matrix(name_new, coupling).array

            # Compare small matrices elementwise, and large matrices by eigenvalues
            if 5 <= num <= 9:
                values_old = np.linalg.eigh(array_old)[0]
                values_new = np.linalg.eigh(array_new)[0]
            else:
                values_old = array_old.ravel()
                values_new = array_new.ravel()
            diff = np.abs(values_new - values_old)
            if np.max(diff) > 1e-7:
                i = np.argmax(diff)
                if show:
                    print(f"Old value {i}: {values_old[i]}")
                    print(f"New value {i}: {values_new[i]}")
                if values_new[i] == 0.0:
                    print(f"{ion} matrix {name_new} [{coupling.name}] is *** different *** ({values_new[i]} != {values_old[i]})")
                else:
                    dev = abs((values_new[i] - values_old[i]) / values_new[i])
                    print(f"{ion} matrix {name_new} [{coupling.name}] is *** different *** ({100*dev:.4f} %)")
            else:
                if show:
                    print(f"{ion} matrix {name_new} [{coupling.name}] is identical")

if __name__ == "__main__":

    for num in range(1, 14):
        compare_old(num, show=False)
    print("Done.")
