##########################################################################
# Copyright (c) 2025 Reinhard Caspary                                    #
# <reinhard.caspary@phoenixd.uni-hannover.de>                            #
# This program is free software under the terms of the MIT license.      #
##########################################################################
#
# Compare matrices from the old Lanthanide-0.3 code with new ones.
#
##########################################################################

import pickle
import math
import numpy as np

from lanthanide import Lanthanide, Coupling, RADIAL, reduced_matrix


def judd_hss(k, names):
    values = {
        0: {
            "3P 3P": -12,
            "3P 3F": (8 / np.sqrt(3)) * 3,
            "3F 3F": (4 * np.sqrt(14) / 3) * -1,
            "3F 3H": (8 * np.sqrt(11 / 2) / 3) * 2,
            "3H 3H": (4 * np.sqrt(143) / 3) * 1,
        },
        2: {
            "3P 3P": -24,
            "3P 3F": (8 / np.sqrt(3)) * 1,
            "3F 3F": (4 * np.sqrt(14) / 3) * 8,
            "3F 3H": (8 * np.sqrt(11 / 2) / 3) * -23 / 11,
            "3H 3H": (4 * np.sqrt(143) / 3) * 34 / 11,
        },
        4: {
            "3P 3P": -300 / 11,
            "3P 3F": (8 / np.sqrt(3)) * -100 / 11,
            "3F 3F": (4 * np.sqrt(14) / 3) * -200 / 11,
            "3F 3H": (8 * np.sqrt(11 / 2) / 3) * -325 / 121,
            "3H 3H": (4 * np.sqrt(143) / 3) * - 1325 / 1573,
        },
    }
    values = values[k]
    print(" | ".join([f"{key}: {value / math.sqrt(5):.3f}" for key, value in values.items()]))
    s5 = math.sqrt(5)
    elements = {}
    for key in values:
        value = values[key] / s5
        elements[key] = value
        key1, key2 = key.split()
        elements[f"{key2} {key1}"] = value

    result = np.zeros((len(names), len(names)), dtype=float)
    for i in range(len(names)):
        for j in range(len(names)):
            key = f"{names[i][:-1]} {names[j][:-1]}"
            if key in elements:
                result[i, j] = elements[key]
    return result


def get_phase(array_old, array_new):
    assert isinstance(array_old, np.ndarray)
    assert isinstance(array_new, np.ndarray)
    assert array_old.shape == array_new.shape

    sign = np.zeros_like(array_old, dtype=int)
    for i in range(0, array_new.shape[0]):
        for j in range(0, array_new.shape[1]):
            value_old = array_old[i, j]
            value_new = array_new[i, j]
            if abs(value_new) < 1e-7 and abs(value_old) < 1e-7:
                continue
            assert abs(value_new * value_old) > 1e-7
            assert abs(abs(value_new) - abs(value_old)) < 1e-7
            sign[i, j] = -1 if value_new * value_old < 0 else 1

    new_signs = np.zeros(array_new.shape[1], dtype=int)
    for j in range(new_signs.shape[0]):
        sign_j = set([s for s in sign[:, j] if s != 0])
        assert len(sign_j) == 1
        new_signs[j] = sign_j.pop()
    return new_signs


def new_name(old_name):
    if "[" in old_name:
        slj, j = old_name.split("[", 1)
        j = j.replace("]", "")
    else:
        slj, j = old_name, None
    if "(" in slj:
        a = slj.index("(")
        b = slj.index(")")
        slj = slj[:a] + slj[b + 1:] + slj[a:b + 1]
    if j is None:
        return slj
    return slj + " " + j


def compare_old(ion, fn, show=False):
    """ Compare matrices generated by the old Lanthanide-0.3 package with current ones. """

    # Retrieve data dictionary from Lanthanide-0.3
    with open(fn, "rb") as fp:
        data = fp.read()
    data = pickle.loads(data)

    # Extract coupling
    coupling = {
        "product": Coupling.Product,
        "sljm": Coupling.SLJM,
        "slj": Coupling.SLJ,
    }[data["coupling"]]

    # Get old and new (short) state names
    states_new = ion.states(coupling)
    names_old = data["names"] if "names" in data else None
    names_new = states_new.short()
    if coupling != Coupling.Product:
        #names_old = [name.replace("[", " ").replace("]", "") for name in names_old]
        names_old = [new_name(name) for name in names_old]
    if show:
        print(f"Old: {' '.join(names_old)}")
        print(f"New: {' '.join(names_new)}")
    assert set(names_new) == set(names_old)

    # Create index map to re-index old matrices to new state order
    new_indices = [names_old.index(name) for name in names_new] if names_old else None

    # Get sign map to adjust the phase of the old transfomation vectors to the new phases
    transform_old = np.array(data["vectors"]).T if "vectors" in data else None
    new_signs = None
    if transform_old is not None:
        transform_old = transform_old[:, new_indices]
        transform_new = ion.states(coupling).transform
        assert transform_new.shape == transform_old.shape
        #with np.printoptions(precision=3, suppress=True, linewidth=200):
        #    f = slice(0, 4)
        #    i = slice(0, 16)
        #    res = pow(10, 3)
        #    print(np.rint(res * transform_old[f, i]) / res)
        #    print()
        #    print(np.rint(res * transform_new[f, i]) / res)

        new_signs = get_phase(transform_old, transform_new)
        if show:
            signs = [{-1: "-", +1: "+"}[sign] for sign in new_signs]
            print(" ".join([sign + name for name, sign in zip(names_new, signs)]))

    # Extract and process all matrices
    keys_old = [key for key in sorted(data.keys()) if key not in ("coupling", "names", "mode", "vectors")]
    for key_old in keys_old:
        if key_old in ("coupling", "names", "mode", "vectors"):
            continue

        # Load and re-index old matrix
        array_old = np.array(data[key_old])
        if coupling != Coupling.Product:
            array_old = array_old[new_indices, :]
            array_old = array_old[:, new_indices]

        # Adjust state phases
        if new_signs is not None:
            array_old *= np.outer(new_signs, new_signs)

        # Translate old matrix name to new one
        args = key_old.split(":")
        name_new = {
            "U1U2T1T2": "UUTT/b/{0},{1},{2},{3},{4}",
            "U1U2": "UU/b/{0}",
            "Hss": "hss/{0}",
            "Hsoo": "hsoo/{0}",
            "H1": "H1/{0}",
            "H2": "H2",
            "H3": "H3/{0}",
            "H4": "H4/{0}",
            "H5": "H5/{0}",
            "H6": "H6/{0}",
        }[args[0]]
        name_new = name_new.format(*map(int, args[1:]))

        # Get new matrix
        array_new = ion.matrix(name_new, coupling).array

        # Compare old and new matrix
        if np.any(np.abs(array_new - array_old) > 1e-7):
            diff = np.abs(array_new - array_old)
            print(f"{ion} matrix {name_new} [{coupling.name}] is *** different *** (max: {np.max(diff)})")
            if show:
                with np.printoptions(precision=3, suppress=True, linewidth=200):
                    f = i = slice(0, 8)
                    res = pow(10, 5)
                    print(f"Old matrix {name_new} [{coupling.name}]")
                    print(np.rint(res * array_old[f, i]) / res)
                    print(f"New matrix {name_new} [{coupling.name}]")
                    print(np.rint(res * array_new[f, i]) / res)
        else:
            print(f"{ion} matrix {name_new} [{coupling.name}] is identical")

if __name__ == "__main__":

    with Lanthanide(4) as ion:
        compare_old(ion, f"../../Lanthanide-0.3/test/extract/f{ion.num:02d}.data", show=False)
    print("Done.")
